//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	public class Edge
	{
		// Represented as an unordered set of two vertices.
		protected Vertex v1, v2;

		private int index;

		/// <summary>
		/// Edge constructor. Requires two distinct vertices, non null vertice.
		/// </summary>
		/// <param name="v1">V1.</param>
		/// <param name="v2">V2.</param>
		public Edge (Vertex v1, Vertex v2, int index)
		{
			if (v1 == null ||
			    v2 == null ||
			    v1 == v2)
			{
				throw new Exception("Illegal Edge Construction");
			}

			this.index = index;

			// Store the vertex references in order from least index to greatest index.
			if (v1.getIndex() < v2.getIndex ())
			{
				this.v1 = v1;
				this.v2 = v2;
			}
			else
			{
				this.v1 = v2;
				this.v2 = v1;
			}
		}

		// -- Public Interface functions.

		public Vertex getOther(Vertex v)
		{
			if (v == v1)
			{
				return v2;
			}

			if(v == v2)
			{
				return v1;
			}

			throw new Exception("Edge: getOther(v), an illegal vertice was passed to this function.");
		}

		public Vertex getV1()
		{
			return v1;
		}

		public Vertex getV2()
		{
			return v2;
		}

		// -- Standard overrid functions.
		public override bool Equals (object obj)
		{
			Edge n = obj as Edge;
			
			// Not a Vertex object.
			if (n == null)
			{
				return false;
			}
			
			return Equals (n);
		}
		
		public bool Equals(Edge e)
		{
			return this == e;
		}
		
		public override int GetHashCode()
		{
			// The number is a large prime number.
			return v1.GetHashCode() + 5342921*v2.GetHashCode();
		}

		public List<Vertex> getVerticeList()
		{
			List<Vertex> output = new List<Vertex>();

			output.Add (v1);
			output.Add (v2);

			return output;
		}
	}
}

